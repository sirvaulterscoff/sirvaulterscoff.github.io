# Docker
## Cgroups
Фича ядра linux, позволяющая задавать лимиты процессам на различные ресурсы системы, такие как CPU, RAM, Disk и тд. Сам по себе cgroups не имеет занимается изоляцией процессов, этим занимается linux namespaces, который позволяет создавать независимые деревья процессов, не имеющие доступа к соседним namespaces. Кстати, chrome использует namespaces для изоляции процессов вкладок. Таким образом docker это cgroups+namespaces

## Основные понятия
### Image
Это слепок файловой системы в которой будет запущен процесс. Если утрировать, то это JSON + tar.gz, внутри которого по нужным путям разложены файлы. На самом деле image композитные и состоят из нескольких последовательных layer.

#### Layer
Layer это один слой файловой системы, содержащий набор изменений, отличающих его от предыдущего слоя. ВАЖНО: layer-ы могут шариться между разными image.

Если совсем просто, то Image это набор .tar.gz архивов, которые последовательно в строгом порядке распаковываются. То что получилось после распаковки и есть результирующая файловая система с которой будет работать процесс контейнера. Каждый image обязательно имеет **ID** и может иметь **tag** (об этом дальше)

### Container
Container это процесс/процессы, запущенные на основе ФС какого-то image. Процессы могут завершаться, тогда завершается и контейнер, а могут выполняться бесконечно долго. Если завершаются все процессы, наследники корневого (PID 1) то завершает работу контейнер и наоборот. Важная особенность - контейнер (и все его процессы) может быть **приостановлен**, а затем исполнение может быть возобновлено.
Важно понимать, что контейнер - это image + запущенные в нем процессы + все изменения на ФС. Т.е. при удалении контейнера все данные теряются

### Volume 
Volume - том, подключаемый к container. Можно рассматривать как внешний диск. Есть масса возможностей/сценариев. Два основных:
 - подмонтировать локальную папку внутрь container. В этом случае процессы могут читать из локальной папки host OS и могут писать в нее. Соответственно так изменения могут переживать пересоздание контейнера
 - подмонтировать папку из другого контейнера. Обычно используется в сложных сценариях развертывания (например kubernetes), когда один контейнер готовит данные (например клонирует git-репозиторий) для второго. 

## Базовые команды
***docker pull*** - скачивает на локальную машину image
***docker run*** - запускает контейнер
***docker stop*** - останавливает контейнер
***docker start*** - возобновляет исполнение контейнера
***docker restart*** - перезапускает контейнер
***docker rm*** - удаляет запущенный или остановленный контейнер

1. Запуск контейнера - docker run. Имя имейджа всегда последнее! После него могут идти только аргументы для запускаемого процесса. Ну и всегда стоит задавать --name для контейнера

```bash
docker run --rm -p 54321:5432 --name db -e POSTGRES_PASSWORD=password postgres
```
![docker run example](https://sirvaulterscoff.github.io/images/docker_run.png)

    
 2. Посмотреть что запущено. ps покажет работающие контнейнеры, ps -a все
```bash
docker ps
```
![docker ps](https://sirvaulterscoff.github.io/images/docker_ps_example.png)
3. Остановить, удалить, перезапустить - docker stop/docker rm (docker rm -f удалит запущенный) /docker start / docker restart. В качестве аргумента передаем или имя (--name аргумент для docker run) или container id

     docker rm -f db

 ## Dockerfile
 Dockerfile описывает какие изменения нужно внести в ФС, чтобы получить какой-то новый образ. 
```Dockerfile
FROM jdk:openjre11-alpine  

ENV APP_ARGS  
WORKDIR /opt/app 
EXPOSE 8080  
COPY build/libs/app.jar .
RUN apk add fontconfig
  
ENTRYPOINT ["java", "-jar", "/opt/app/app.jar", "$APP_ARGS"]
```
 Ключевые элементы
 1. FROM указывает образ на основании которого нужно собрать новый. Т.е. берем базовый образ, в него добавляем (или удаляем из него) файлы, получаем новый образ. Совсем пустой образ - scratch
 2. ENV - декларируем, что есть переменная. Может быть использована внутри Dockerfile. Например, можно использовать в COPY, но нужно понимать, что в этом случае ее значение будет использовано один раз. Значение может быть задано при запуске через -e. Если переменная не определена через ENV не означает, что ее значение нельзя задать через -e
 3. WORKDIR - просто указываем в какой директории выполнять последующие команды
 4. EXPOSE - указываем какие порты открывает приложение. Опять же, больше информационный параметр. Можно будет опубликовать любой порт через аргумент -p
 5. COPY - первый главный  инструмент модификации файловой системы образа. Копирует файл (файлы) из директории, где был запущен docker build в какую-то директорию внутри image (точнее layer). Каждая команда COPY создает отдельный layer
 6. RUN запускает какую-то команду внутри  образа при сборке. Запустить можно только те команды, которые присутствуют в собираемом образе или в базовых. Все что команда запишет на ФС будет сохранено как отдельный layer. Для уменьшения количества слоев нужно объединять неск команд в один RUN
 7. ENTRYPOINT - какую команду docker выполнит при запуске контейнера. Есть еще CMD. Разница в том, что при использовании CMD docker запустит bash и передаст ему CMD в виде аргумента. 

Как собрать образ
```bash
docker build . -t my-app:version
```
![enter image description here](https://sirvaulterscoff.github.io/images/docker_build.png)

Что происходит во время выполнения команды:

- содержимое указанной директории упаковывается архив и передается сервису докера - это контекст. Таким образом, в Dockerfile нельзя указывать команды вида COPY ../../somefile т.к. такого файла просто не будет в контексте
- выполняются все команды из файла. Полученные в процессе layer объединяются в image
- проставляется имя + тег для созданного image. Это идентично выполнению команды docker tag imageid myapp:version

Для чего имена и теги:
1. по имени проще работать с image
2. теги позволяют задавать версии. Есть специальный тег :latest - он выкачивает всегда последнюю версию. Использовать :latest во FROM крайне не рекомендуется, т.к. сборка может в один прекрасный момент поломаться.
3. имена так же указываю в какой docker registry отправить image. Например nexus.company.ru/docker/myapp:1.0 позволит затем выполнить docker push и опубликовать этот image в общем репозитории. Некоторые репозитории требуют аутентификации - для это цели docker login

## We need to go deeper
Как можно взаимодействовать с тем, что запущено ?
1. docker exec - позволяет выполнить команду внутри запущенного container 
```bash 
docker exec -it db /bin/bash
```
![enter image description here](https://sirvaulterscoff.github.io/images/docker_exec.png)

2. docker cp - позволяет копировать файлы в/из запущенного контейнера
```bash
docker cp README.md db:/tmp
```  

## More advanced stuff
Build container. Это такая штука, которая позволяет разделить сборку результирующего docker image на две фазы. В первой фазе собирается промежуточный docker image внутри которого запускаются команды. Затем собирается финальный docker image в который можно будет скопировать часть файлов из первого контейнера

```Dockerfile
FROM gradle as builder
RUN ./gradlew clean build

FROM gradle
COPY --from=build ~/.m2 ~/.m2
ENTRYPOINT ["gradle"]
```

Так, например, можно собрать image, который помимо gradle будет так же содержать и maven репозиторий со скачанными зависимостями. 
