<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ACM_Inheritance</title>
  <link rel="stylesheet" href="https://stackedit.io/style.css" />
</head>

<body class="stackedit">
  <div class="stackedit__html"><p><strong>Наследование АЦМ</strong></p>
<ol>
<li>На схеме отрисовываем типовой документ. В коде он должен соответствовать какому-то интерфейсу. Тут важно понимать, что в этом сценарии наследование документов должно строго следовать допустимой модели наследования Kotlin, т.е. допускать ТОЛЬКО расширение атрибутного состава (следовательно, не допускать сужение, переопределение)</li>
<li>Типовые артефакты поступают в очереди, именованные по классу типового артефакта, т.е. IncomingDocument.CREATED. Если на уровне модели определен кто-то, кто может читать такой типовой артефакт, то он будет считан. Тут вопрос, что делать, если типовой артефакт не потребляет ни один процесс</li>
<li>Если требуется переопределить типовую операцию для конкретного документа, то у нас есть несколько вариантов:</li>
</ol>
<ul>
<li>в концепцию сервиса артефактов заложить переопределение операции (как было сделано для ЖЦ). Т.е. перед запуском эктора, соотвествующего текущему базовому артефакту из артефакта достаем конкретный вид документа и пытаемся понять есть ли какой-то бин, который переопределяет этот процесс</li>
<li>на схеме отрисовывается процесс с таким же идентификатором, но другими входными артефактами (т.е. конкретными документами). Это вносит путаницу в то, какой процесс на самом деле будет запущен</li>
</ul>
<ol start="4">
<li>Основной вопрос - как при переопределении операции вернуть документ так, чтобы он опять подхватился базовой моделью. Как вариант, для переопределенных операций в качестве исходящего артефакта нужно описывать базовый документ, а не конкретный.</li>
</ol>
</div>
</body>

</html>
